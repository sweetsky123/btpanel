import{c as e,r as a,o as l,g as t,v as r,x as c,y as o,e as i,C as s,z as m,F as u,b1 as p,J as d,K as n,A as h,D as _,B as v,an as k,ad as f,ab as b,am as w}from"./base-lib.js?v=1763689792";import{X as g,Q as j,k as V,b as y,_ as D}from"./utils-lib.js?v=1763689792";import{groupProjectConfig as x}from"./site.js?v=1763689792";import"./__commonjsHelpers__.js?v=1763689792";const E={class:"p-[2rem]"},U={class:"flex items-center mt-[1.6rem] ml-[3rem]"},q={class:"mt-[1.6rem] leading-8 text-small list-disc ml-[2rem]"},A=D(e({__name:"project-check",props:{compData:{default:{}}},setup(e,{expose:D}){const A=e,C=y(),F=a(),J=a(!1),N=l({check:"a;;",port:"",wait_time:180}),z={check:{required:!0,message:"请输入检测策略",trigger:"blur"},port:[{validator:(e,a,l)=>{a.split(",").filter(e=>""!==e).some(e=>!g(e))&&"port"==N.check?l(new Error("请输入正确的端口")):l()}}],wait_time:[{validator:(e,a,l)=>{a<=0&&"active"==N.check||""==a&&"active"==N.check?l(new Error("请输入正确的进程存活时长")):l()}}]},B=[{value:"all",label:"任意端口监听"},{value:"port",label:"指定端口监听"},{value:"active",label:"进程存活时长"}],H=t(()=>{switch(N.check){case"all":return"任意端口监听策略，执行启动后,项目进程直到出现任意一个端口监听后, 才认定为启动成功,最大默认等待3分钟";case"port":return"指定端口监听策略，执行启动后，项目进程直到监听【".concat(N.port,"】端口后，才认定为启动成功,最大默认等待3分钟");case"active":return"进程存活时长，解释:启动该项目后，在【".concat(N.wait_time,"】秒内自动退出则认定为启动成功");default:return""}});return r(()=>{var e,a,l,t,r;e=A.compData,N.check=(null==(a=e.check_info)?void 0:a.type)||"all","port"===N.check&&0==(null==(l=e.check_info)?void 0:l.port.length)&&(N.check="all"),N.port=(null==(t=e.check_info)?void 0:t.port.join(","))||"",N.wait_time=Number((null==(r=e.check_info)?void 0:r.wait_time)||180)}),D({onConfirm:async e=>{if("active"==N.check&&(N.wait_time<=0||""==N.wait_time))return C.error("请输入正确的进程存活时长");await F.value.validate(),j({loading:J,request:x({group_id:A.compData.group_id,project_id:A.compData.id,check_info:JSON.stringify({type:"all"==N.check?"port":N.check,port:"port"==N.check?N.port.split(","):[],wait_time:"active"==N.check?N.wait_time:180})}),success:a=>{a.status&&(A.compData.refreshEvent&&A.compData.refreshEvent(),e&&e())}})}}),(e,a)=>{const l=w,t=k,r=f,g=V,j=b;return c(),o("div",E,[i(j,{ref_key:"javaAddFormRef",ref:F,model:m(N),disabled:m(J),"label-width":"9rem",rules:z},{default:s(()=>[i(r,{label:"检测策略",prop:"check"},{default:s(()=>[i(t,{modelValue:m(N).check,"onUpdate:modelValue":a[0]||(a[0]=e=>m(N).check=e),class:"!w-[22rem]",placeholder:"请选择"},{default:s(()=>[(c(),o(u,null,p(B,e=>i(l,{key:e.value,label:e.label,value:e.value},null,8,["label","value"])),64))]),_:1},8,["modelValue"])]),_:1}),d(i(r,{label:"端口",prop:"port"},{default:s(()=>[i(g,{modelValue:m(N).port,"onUpdate:modelValue":a[1]||(a[1]=e=>m(N).port=e),placeholder:"多个用,分隔",width:"22rem"},null,8,["modelValue"])]),_:1},512),[[n,"port"==m(N).check]]),d(h("div",U,[a[3]||(a[3]=_(" 启动该项目后，在 ",-1)),i(g,{modelValue:m(N).wait_time,"onUpdate:modelValue":a[2]||(a[2]=e=>m(N).wait_time=e),type:"number",width:"8rem",class:"!mx-[1rem]"},null,8,["modelValue"]),a[4]||(a[4]=_(" 秒内自动退出则认定为启动成功 ",-1))],512),[[n,"active"==m(N).check]])]),_:1},8,["model","disabled"]),h("ul",q,[h("li",null,"当前效果："+v(m(H)),1),a[5]||(a[5]=h("li",null,"检查策略：主要是为了确认当前项目是否启动成功，保证顺序启动时，能在合适的情况下中断后续操作",-1)),a[6]||(a[6]=h("li",null,"任意端口监听策略（默认）：启动后，进程出现监听任意端口视为启动成功（最大等待3分钟）",-1)),a[7]||(a[7]=h("li",null,"指定端口监听策略：启动后，进程出现监听了您指定的所有端口后，视为启动成功（最大等待3分钟）",-1)),a[8]||(a[8]=h("li",null,"进程存活时长：启动后，进程在指定时长内未退出，则视为启动成功",-1))])])}}}),[["__scopeId","data-v-5a19ff05"]]);export{A as default};
